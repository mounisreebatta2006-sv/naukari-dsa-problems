Problem statement
You have been given a Binary Tree of 'N' nodes. Your task is to find and return the deepest right leaf node. In case of multiple answers, return the rightmost node.
Sample Input 1:
1 2 3 -1 -1 -1 -1
Sample Output 1:
3
Explanation to Sample Output 1:
From the above representation, the leaves node are 2 and 3. But 3 is the right child of its parent but 2 is the left child of its parent. Thus, 3 should be the answer.
Sample Input 2:
1 2 3 -1 4 4 -1 -1 5 6 -1 -1 -1 -1 -1
Sample Output 2:
5
Explanation to Sample Output 2:
The input binary tree will be represented as: 
From the above representation, the leaves node are 5 and 6. But 5 is the right child of its parent but 6 is the left child of its parent. Thus, 5 should be the answer.

class Node
{
Node left;
Node right;
int data;
Node(int data)
{
this.data=data;
this.left=null;
this.right=null;
}
}
class Solution
{
public static Node findright(Node root)
{
Node ans=new Node(-1);
Queue<Node>queue=new LinkedList<>();
queue.offer(root);
while(!queue.isEmpty())
{
Node curr=queue.poll();
if(curr.left!=null)
{
  queue.offer(curr.left);
}
if(curr.right!=null)
{
queue.offer(curr.right);
if(curr.right.left==null && curr.left.right==null)
{
  ans=curr.right;
}
}
}
return ans;
}
}
