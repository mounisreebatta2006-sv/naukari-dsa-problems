Problem statement
You are given an arbitrary binary tree consisting of N nodes numbered from 1 to N, an integer 'K', and a node 'TARGET_NODE_VAL' from the tree. You need to find the Kth ancestor of the node 'TARGET_NODE_VAL'. If there is no such ancestor, then print -1.
The Kth ancestor of a node in a binary tree is the Kth node in the path going up from the given node to the root of the tree. Refer to sample test cases for further explanation.
Note:
1. The given node 'TARGET_NODE_VAL' is always present in the tree.
2. The value of each node in the tree is unique.
3. Notice that the Kth ancests.daor node if present will always be unique.
here we can solve these problem through dfs+backtracking which is very efficient and it is perfect approach to solve these problem 
Sample Input 1:
1
1 2 3 4 5 -1 -1 -1 -1 -1 -1
5 2
Sample Output 1:
1

class Node
{
int data;
Node left;
Node right;
Node(int data)
{
this.data=data;
this.left=null;
this.right=null;
}
}
import java.util.*;
class Solution
{
public static int kthancistor(Node root,int target,int k)
{
ArrayList<Integer>path=new ArrayList<>();
findpath(root,path,target);
int idx=path.size()-k-1;
if(idx<0) return -1;

return path.get(idx);
}
public static boolean findpath(Node root,ArrayList<Integer>path,int target)
{
if(root==null) return false;
path.add(root.data);
if(root.data==target) return true;
if(findpath(root.left,path,target)||findpath(root.right,path,target)) return true;
path.remove(path.size()-1);
return false;
}
}
